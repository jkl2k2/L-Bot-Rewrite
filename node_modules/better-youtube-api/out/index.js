"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const entities_1 = require("./entities");
const util_1 = require("./util");
const caching_1 = require("./util/caching");
const oauth_1 = require("./oauth");
__export(require("./entities"));
/**
 * The main class used to interact with the YouTube API. Use this.
 */
class YouTube {
    /**
     *
     * @param token Your YouTube Data API v3 token. Don't share this with anybody.
     * It could be an API key or an OAuth 2.0 token.
     * @param options Caching options. Recommended to change.
     */
    constructor(token, options = { cache: true, cacheTTL: 600, cacheCheckInterval: 600, cacheSearches: false }) {
        this.token = token;
        this.oauth = new oauth_1.OAuth(this);
        this._shouldCache = options.cache;
        this._cacheSearches = options.cacheSearches;
        this._cacheTTL = options.cacheTTL;
        if (options.cacheCheckInterval > 0) {
            setInterval(caching_1.Cache.checkTTLs, options.cacheCheckInterval * 1000);
        }
    }
    get token() {
        return this._token;
    }
    set token(val) {
        this._token = val;
        this.tokenType = val.startsWith('ya29') ? 'oauth' : 'key';
    }
    _cache(id, value) {
        if (!this._shouldCache) {
            return;
        }
        caching_1.Cache.set(id, value, this._cacheTTL > 0 ? this._cacheTTL * 1000 + new Date().getTime() : 0);
    }
    /**
     * Search supported entities on YouTube.
     * @param types An array of types to search for. May be a single type or multiple types.
     * @param searchTerm What to search for on YouTube.
     * @param maxResults The maximum amount of results to find. Defaults to 10.
     */
    search(types, searchTerm, maxResults = 10) {
        return this._search(types, searchTerm, maxResults);
    }
    /**
     * Search videos on YouTube.
     * @param searchTerm What to search for on YouTube.
     * @param maxResults The maximum amount of results to find. Defaults to 10.
     */
    searchVideos(searchTerm, maxResults = 10) {
        return this.search([entities_1.Video], searchTerm, maxResults);
    }
    /**
     * Search channels on YouTube.
     * @param searchTerm What to search for on YouTube.
     * @param maxResults The maximum amount of results to find. Defaults to 10.
     */
    searchChannels(searchTerm, maxResults = 10) {
        return this.search([entities_1.Channel], searchTerm, maxResults);
    }
    /**
     * Search playlists on YouTube.
     * @param searchTerm What to search for on YouTube.
     * @param maxResults The maximum amount of results to find. Defaults to 10.
     */
    searchPlaylists(searchTerm, maxResults = 10) {
        return this.search([entities_1.Playlist], searchTerm, maxResults);
    }
    /**
     * Get a video object from the URL, ID, or Title of a video.
     * @param videoResolvable The URL, ID, or Title of the video.
     */
    getVideo(videoResolvable) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = yield this.getId(videoResolvable, 'video');
            return this.getItemById(entities_1.Video, id);
        });
    }
    /**
     * Get a channel object from the Username, URL or ID of a channel.
     * @param channelResolvable The Username, URL or ID of the channel.
     */
    getChannel(channelResolvable) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = yield this.getId(channelResolvable, 'channel');
            return this.getItemById(entities_1.Channel, id);
        });
    }
    /**
     * Get a playlist object from the URL, ID, or Title of a playlist.
     * @param playlistResolvable The URL, ID, or Title of the playlist.
     */
    getPlaylist(playlistResolvable) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = yield this.getId(playlistResolvable, 'playlist');
            return this.getItemById(entities_1.Playlist, id);
        });
    }
    /**
     * Get a comment object from the ID of a comment.
     * @param id The ID of the comment.
     */
    getComment(commentId) {
        return this.getItemById(entities_1.YTComment, commentId);
    }
    /**
     * @deprecated Use getVideo() instead
     * Get a video object from the url of a video.
     * @param url The url of the video.
     */
    /* istanbul ignore next */
    getVideoByUrl(url) {
        const id = util_1.parseUrl(url);
        if (!id.video) {
            return Promise.reject('Not a valid video url');
        }
        return this.getItemById(entities_1.Video, id.video);
    }
    /**
     * @deprecated Use getChannel() instead
     * Get a channel object from the url of a channel.
     * @param url The url of the channel.
     */
    /* istanbul ignore next */
    getChannelByUrl(url) {
        const id = util_1.parseUrl(url);
        if (!id.channel) {
            return Promise.reject('Not a valid channel url');
        }
        return this.getItemById(entities_1.Channel, id.channel);
    }
    /**
     * @deprecated Use getPlaylist() instead
     * Get a playlist object from the url of a playlist.
     * @param url The url of the playlist.
     */
    /* istanbul ignore next */
    getPlaylistByUrl(url) {
        const id = util_1.parseUrl(url);
        if (!id.playlist) {
            return Promise.reject('Not a valid playlist url');
        }
        return this.getItemById(entities_1.Playlist, id.playlist);
    }
    /**
     * Get `maxResults` videos in a playlist. Used mostly internally with `Playlist#fetchVideos`.
     * @param playlistResolvable The URL, ID, or Title of the playlist.
     * @param maxResults The maximum amount of videos to get from the playlist. If <= 0 or not included, returns all videos in the playlist.
     */
    getPlaylistItems(playlistResolvable, maxResults = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const playlistId = yield this.getId(playlistResolvable, 'playlist');
            return this.getPaginatedItems('playlistItems', playlistId, maxResults);
        });
    }
    /**
     * Get `maxResults` comments from a video. Used mostly internally with `Video#fetchComments`.
     * @param videoResolvable The URL, ID, or Title of the video.
     * @param maxResults The maximum amount of comments to get from the video. If <= 0 or not included, returns all comments on the video.
     */
    getVideoComments(videoResolvable, maxResults = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const videoId = yield this.getId(videoResolvable, 'video');
            return this.getPaginatedItems('commentThreads:video', videoId, maxResults);
        });
    }
    /**
     * Get `maxResults` comments from a channel's discussion tab. Used mostly internally with `Channel#fetchComments`.
     * @param channelResolvable The Username, URL, or ID of the channel.
     * @param maxResults The maximum amount of comments to get from the channel. If <= 0 or not included, returns all comments on the channel.
     */
    getChannelComments(channelResolvable, maxResults = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const channelId = yield this.getId(channelResolvable, 'channel');
            return this.getPaginatedItems('commentThreads:channel', channelId, maxResults);
        });
    }
    /**
     * Get `maxResults` of a channel's playlists. Used mostly internally with `Channel#fetchPlaylists`.
     * @param channelResolvable The Username, URL, or ID of the channel.
     * @param maxResults The maximum amount of playlists to get from the channel. If <= 0 or not included, returns all playlists.
     */
    getChannelPlaylists(channelResolvable, maxResults = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const channelId = yield this.getId(channelResolvable, 'channel');
            return this.getPaginatedItems('playlists:channel', channelId, maxResults);
        });
    }
    /**
     * Get `maxResults` replies to a comment. Used mostly internally with `Comment#fetchReplies`.
     * @param commentId The ID of the comment to get replies from.
     * @param maxResults The maximum amount of replies to get. Gets all replies if <= 0 or not included.
     */
    getCommentReplies(commentId, maxResults = -1) {
        return this.getPaginatedItems('comments', commentId, maxResults);
    }
    /* istanbul ignore next */
    _search(types, searchTerm, maxResults = 10) {
        return __awaiter(this, void 0, void 0, function* () {
            const type = types.map(t => t.endpoint.substring(0, t.endpoint.length - 1)).join(',');
            const cached = caching_1.Cache.get(`search://${type}/"${searchTerm}"/${maxResults}`);
            if (this._shouldCache && cached) {
                return cached;
            }
            if (maxResults < 1 || maxResults > 50) {
                return Promise.reject('Max results must be greater than 0 and less than or equal to 50');
            }
            const fields = 'items(kind,id,snippet(title,description,thumbnails,publishedAt,channelId))';
            const results = yield util_1.request.api('search', {
                q: encodeURIComponent(searchTerm),
                fields: encodeURIComponent(fields),
                maxResults,
                part: 'snippet',
                type
            }, this.token, this.tokenType);
            const items = [];
            results.items.forEach(item => {
                if (item.id.videoId) {
                    items.push(new entities_1.Video(this, item));
                }
                else if (item.id.channelId) {
                    items.push(new entities_1.Channel(this, item));
                }
                else if (item.id.playlistId) {
                    items.push(new entities_1.Playlist(this, item));
                }
            });
            if (this._shouldCache && this._cacheSearches) {
                this._cache(`search://${type}/"${searchTerm}"/${maxResults}`, items);
            }
            return items;
        });
    }
    /* istanbul ignore next */
    getItemById(type, id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!([entities_1.Video, entities_1.Channel, entities_1.Playlist, entities_1.YTComment].includes(type))) {
                return Promise.reject('Type must be a video, channel, playlist, or comment.');
            }
            const cached = caching_1.Cache.get(`get://${type.endpoint}/${id}`);
            if (this._shouldCache && cached) {
                return cached;
            }
            const result = yield util_1.request.api(type.endpoint, {
                id,
                fields: encodeURIComponent(type.fields),
                part: type.part
            }, this.token, this.tokenType);
            if (result.items.length === 0) {
                return Promise.reject('Item not found');
            }
            let endResult = new type(this, result.items[0], result.items[0].snippet.channelId ? 'channel' : 'video');
            if (this._shouldCache) {
                this._cache(`get://${type.endpoint}/${id}`, endResult);
            }
            return endResult;
        });
    }
    /* istanbul ignore next */
    getPaginatedItems(endpoint, id, maxResults = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const cached = caching_1.Cache.get(`get://${endpoint}/${id}/${maxResults}`);
            if (this._shouldCache && cached) {
                return cached;
            }
            let full;
            let items = [];
            if (maxResults <= 0) {
                full = true;
            }
            else {
                full = false;
            }
            const options = {
                part: 'snippet',
                maxResults: 0
            };
            let max;
            let clazz;
            let commentType;
            if (endpoint === 'playlistItems') {
                max = 50;
                clazz = entities_1.Video;
                options.playlistId = id;
            }
            else if (endpoint.startsWith('commentThreads')) {
                max = 100;
                clazz = entities_1.YTComment;
                const [, type] = endpoint.split(':');
                commentType = type ? type : 'video';
                endpoint = 'commentThreads';
                options[`${type}Id`] = id;
                options.part += ',replies';
                options.textFormat = 'plainText';
            }
            else if (endpoint === 'comments') {
                max = 100;
                clazz = entities_1.YTComment;
                options.parentId = id;
            }
            else if (endpoint === 'playlists:channel') {
                max = 50;
                clazz = entities_1.Playlist;
                endpoint = 'playlists';
                options.part += ',contentDetails,player';
                options.channelId = id;
            }
            else {
                return Promise.reject('Unknown item type ' + endpoint);
            }
            if (maxResults > max) {
                return Promise.reject(`Max results must be ${max} or below for ${endpoint}`);
            }
            options.maxResults = full ? max : maxResults;
            let results;
            let pages = null;
            let shouldReturn = !full;
            for (let i = 1; i < pages ? pages : 3; i++) {
                results = yield util_1.request.api(endpoint, options, this.token, this.tokenType).catch(() => {
                    return Promise.reject('Items not found');
                });
                if (results.items.length === 0) {
                    return Promise.reject('Items not found');
                }
                if (!pages) {
                    pages = results.pageInfo.totalResults / results.pageInfo.resultsPerPage;
                    if (pages <= 1) {
                        shouldReturn = true;
                    }
                    pages = Math.floor(pages);
                }
                results.items.forEach(item => {
                    let comment;
                    if (item.snippet.topLevelComment) {
                        comment = new entities_1.YTComment(this, item.snippet.topLevelComment, commentType);
                        items.push(comment);
                    }
                    else {
                        items.push(new clazz(this, item, commentType));
                    }
                    if (item.replies) {
                        item.replies.comments.forEach(reply => {
                            const created = new entities_1.YTComment(this, reply, commentType);
                            comment.replies.push(created);
                        });
                    }
                });
                if (results.nextPageToken && !shouldReturn) {
                    options.pageToken = results.nextPageToken;
                }
                else {
                    return items;
                }
            }
            if (this._shouldCache) {
                this._cache(`get://${endpoint}/${id}/${maxResults}`, items);
            }
            return items;
        });
    }
    /* istanbul ignore next */
    getId(input, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let id = null;
            if (input.includes('youtube.com') || input.includes('youtu.be')) {
                const idFromUrl = util_1.parseUrl(input)[type];
                // Custom channel URLs don't work that well
                if (type === 'channel' && idFromUrl && !idFromUrl.startsWith('UC')) {
                    id = yield util_1.request.api('search', { q: idFromUrl, type, part: 'id' }, this.token, this.tokenType).then(r => r.items[0] ? r.items[0].id.channelId : undefined);
                }
                id = idFromUrl;
            }
            if (id !== null && id !== undefined && id !== '') {
                return id;
            }
            if (type === 'channel' && (!input.startsWith('UC') || input.includes(' '))) {
                id = yield util_1.request.api('search', { q: input, type, part: 'id', maxResults: 1 }, this.token, this.tokenType).then(r => r.items[0] ? r.items[0].id.channelId : undefined);
            }
            else if (type === 'playlist' && input.includes(' ')) {
                id = yield util_1.request.api('search', { q: input, type, part: 'id', maxResults: 1 }, this.token, this.tokenType).then(r => r.items[0] ? r.items[0].id.playlistId : undefined);
            }
            else if (type === 'video' && (input.length < 11 || input.includes(' '))) {
                id = yield util_1.request.api('search', { q: input, type, part: 'id', maxResults: 1 }, this.token, this.tokenType).then(r => r.items[0] ? r.items[0].id.videoId : undefined);
            }
            else {
                id = input;
            }
            if (id === null || id === undefined || id === '') {
                return Promise.reject('Item not found');
            }
            return id;
        });
    }
}
exports.YouTube = YouTube;
exports.default = YouTube;

//# sourceMappingURL=index.js.map
